第2章 融于心而表于行
2.2 用户的身份
2.2.2	虽然用户角色不能跟权限靠上关系，但不同的角色有些时候还是有待遇差别的。所谓的待遇就是是否拥有密码、home目录以及shell(后面的章节会详细介绍)这些资源。有些用户的主要任务就是运行某些服务程序以确保安全性的，比如nobody用户就可以用于Nginx的工作进程。对于这类的用户一般是不分配密码和shell②的，甚至home目录也没有。为什么这样做呢?
首先，可能会有很多服务程序默认使用这个用户，如果设置了密码，程序就无法自动使用了;其次，因为不会有人使用这个用户登录系统，也就没有必要分配一个shell给它，私密的home目录也有些多余。

2.2.3 /etc/passwd文件查看用户：从这个文件名上看，应该是跟密码有关。的确是这样，只是那己经成为历史了。现在保存密码的文件是/etc/shadow，也就是传说中的影子文件。现在我们只需要关心/etc/passwd文件，它是用来存放用户基本信息的。

2.2.5  useradd [username]， 添加一个新用户
passwd [username]，修改用户的密码
userdel [option] [username]，删除一个用户，option为-r时是将该用户的home目录一同删掉

2.2.6  sudo cat /etc/shadow 普通用户假借root用户身份，同时被要求输入密码。缺点在于每个命令前都要加sudo。
su命令则是做临时的用户切换，默认切换到root用户，输入密码，一旦切换完成，就会将当前用户转换成目标用户，exit命令可以切回原始用户。

2.2.7  实际用户为登录时所使用的用户，有效用户为当前执行操作的用户。
以普通用户jason登入，再用su切换到root用户，那么
whoami  root; 
root为当前有效用户。

2.3 文件和它与权限的关系
2.3.2 使用ls –l 可以查看文件的属性和权限，加-a参数可以看到隐藏文件。

2.3.3  ln –s /bin/bash sh会创建一个新的软链接sh指向/bin/bash，类似于快捷方式；ln /bin/bash sh则是创建硬链接。每个文件都有唯一的incode编号，可以简单理解为一个指针，指向文件在磁盘的物理位置，文件的属性也保存在incode当中，系统则是通过incode定位每一个文件而不是文件名。Linux允许一个文件拥有多个名字，一个文件名等价于对incode的一次引用，“连接数”就是incode的引用计数，若有两个文件名则“连接数”为2。硬链接使得一个文件拥有多个路径，删除动作只不过是引用计数-1，可以防止文件被恶意删除。

2.3.4  chown [-R] username filename更改文件的拥有者。
chown [-R] username: group filename 连同文件所属的用户组一同修改，其中-R参数是可选的，意思是将目录下的所有文件包括子目录在内全部改成指定的拥有者。
chmod 755 bash 使用”ls -al”查看bash的权限，应该是”-rwxr-xr-x”
r=4, w=2, x=1, so r-x=5, rw-=6, rwx=7
2.3.5  SUID与SGID略

2.3.6  Linux中有几个特别的目录名，分别是：“.”、“..”、“-”、“~”
“.”、“..”分别代表当前目录和上一级目录，由于“.”目录的存在，使得每个目录的“连接数”属性为2；由于“..”目录的存在，当前目录每增加一个子目录，当前目录的“连接数”属性+1。根目录的“.”“..”完全相同，都是根目录。
“-”为上一个工作目录，“~”为当前用户的home目录，它们实际上只是cd命令的特殊参数。Linux系统下没有创建文件的命令，因为文件不是已经存在了就是由程序生成了，mkdir是创建文件夹。如果非要创建一个文本文档，也许 echo (内容不限) ->a.txt可以使用。
Linux下的5个常用文件管理命令：ls列举、cd打开文件夹、cp复制、rm移除、mv移动或重命名。

2.3.7 搜索文件命令whereis ls可以搜索到“ls”命令及其联机帮助文档的位置，在一个数据库(/var/lib/mlocate/)中查询，每天系统自动执行updatedb命令更新一次，因此时效性不太好，若要获得准确的搜索结果，可以手动执行updatedb命令。locate和whereis类似且使用相同的数据库，但更全面，在准确性方面就牺牲了，locate的搜索会匹配文件名和出现过的路径，加上-b参数可以只列出路径。
更常用的搜索命令是which，它用来搜索$PATH环境变量(保存可执行文件的默认搜索路径)，一般用来确认系统中是否安装了指定的软件。
对于这样的精确查询条件的设定，find还有许多许多，而这仅仅是查询条件。
find不仅仅可以设置十分精确的查询条件，还能规范对找到的文件做什么动作。比如我们要列出一天以内变化的文件的详细信息，可以使用类似这样的命令:
$ find  /  -mtime  -1  -exec ls  -l  {}  \;
-exec是find命令对找到的文件执行的动作，这个动作就是对找到的文件执行命令。这个执行的命令就写在了它的后面，在我们的例子中是“1s-1 {}"。其实最迷惑人的就是这里，很多人搞不清楚“{}”是什么意思。其实它就是一个站位符，在find命令的执行过程中会不断地被替换成当前找到的文件。这样在本例中 ls命令就完整了，能够显示想要的文件的详细信息了。具体的命令执行过程弄清楚之后，就是后面的这个“\;”，更加让人摸不到头脑。为什么呢?因为Linux的联机帮助上说-exec的命令结束标记是“;”。但是我们在实际使用过程中如果真是这样用的，就总是报错，find拒绝工作。其实这是shell的错，“;”在bash ( Linux的默认shell，几乎所有发行版本都是这样)环境中有特殊含义，所以需要使用“\”来转义一下。
find无所不及但效率极差，需要设置十分精确的查询条件。
find / -mtime 3 表示查询3天前的那一天发生变化的所有文件；
find / -mtime -3 表示3天内~；find / -mtime +3表示3天以前~；

2.3.8 一个完整的软件需要：库文件、配置文件、可执行文件等；一个源代码需要不同的模块：数据、控制、视图等。
Linux的压缩文件有类似：*.tar.gz、*.tar.bz2、*.tar.xz，压缩比gz<bz2<xz。
解压缩命令：tar –vx –f filename 或tar –vxf filename可以解压缩所有类型的tar包，而创建压缩包只是多了一个命令选项，这个多出来的命令选项就是采用的压缩算法。z代表gz，j代表bz2，J代表xz。例如：
tar  –zcvf  filename.tar.gz  FILES
tar  –jcvf  filename.tar.gz  FILES
tar  –Jcvf  filename.tar.gz  FILES
其中FILES代表要被打包和压缩的文件或者目录的名称。
dump和restore是一对备份还原工具；cpio也可以完成打包解包备份的工作，不过其输入输出为标准输入输出流，需要使用一定的方式才能输出到磁盘。
打包：find  …  |  cpio –ocB  >  filename
解包：cpio  –idc  <  …/filename 把某路径下的压缩包解压到当前路径
如果是find  ./  |  cpio –ocB  >  yasuo ，此时yasuo这个包也在当前文件夹里，那么执行这条命令时，yasuo这个包里会多出现一个同样名叫yasuo的文件，因为find和cpio这两个指令是同时执行的，一开始yasuo这个包就会被创建，然后被find找到后又被压缩进自己…

2.4 程序的执行问题
2.4.1 当你要执行当前所在目录下的一个可执行文件时，Windows系统下直接敲入该程序名就能执行，但Linux不能，Linux系统只会在$PATH环境变量所指定的那些路径中搜索对应的程序（Windows会先搜索当前目录再搜索$PATH）。Linux如果要执行不在$PATH路径中的程序，必须使用相对路径，可以使用 ./abc.exe 扩展名也要敲入不可省略。
如果我们要将/boot目录下的所有文件打包成一个文件，可以执行这样的命令：
find  /boot  |  cpio –ocB  >  /tmp/boot.img
两个命令之间的竖线“|”称为管道符，也叫匿名管道，数据只能从管道的一端写入并从另一端读取，也叫FIFO(First Input First Output)。
命令格式：命令A|命令B，即命令A的正确输出作为命令B的操作对象。
上述命令涉及到Linux的一项技术叫I/O重定向，隐式重定向发生在“匿名管道”处，find命令将原本输出给屏幕的东西重定向给了管道写入端，而cpio则将原本从键盘获得的输入重定向到管道的输出端，从而接受find所给的内容。“>”就是显性重定向，它将cpio原本应输出到屏幕的内容重定向到磁盘文件中。
输出重定向
>代表以覆盖的方式将命令的正确输出输出到指定的文件或设备当中。
输入重定向
命令<文件名：把文件作为命令的输入
Ctrl+Z可以实现将当前任务切换为后台任务。
比如 $ tail  –f  etc/profile 按下Ctrl+Z可以看到
[1]+  Stopped  tail  –f  etc/profile （带+号属于当前默认的任务）
然后执行命令bg可以将后台悬挂的（停止的）任务转为运行，
可以看到$ tail  –f  etc/profile & 使用jobs可以查看任务状态，
然后看到[1]+  Running  tail  –f  etc/profile
$ tail  –f  etc/profile & 也可以用来直接创建一个后台任务；
fg 1 会将1号任务切换到前台；
Ctrl+C可以将当前任务干掉！
$ kill  -9  %2就可以杀死2号任务，-9表示强制干掉，默认-15正常结束。
任务与终端是紧密联系的，终端关闭所有任务就会被关掉，使用
$ nohup  [命令与参数]  & 就可以使任务脱离与终端的关联。需要注意的是这样命令的所有输出都会输出到nohup.out文件中。

2.4.2 创建一次性任务：$ at 10:00 tomorrow会出现 at> 然后就输入想执行的命令比如echo “haha”，可以输入多行命令，然后按Ctrl+D保存。最好使用全路径来执行任务才是好习惯，就是写全命令的路径，比如/bin/echo “haha”。
创建周期性的任务：$ crontab –e 编辑当前用户的cron表，-l是查看，-r是删除当前用户的cron进程，-u+用户名是以某身份来控制cron表。
一个corn任务的完整定义是：分钟 小时 日 月 周 [用户名] 命令
取值范围：分钟0~59  小时0~23  日0~31 月1~12 周几0~6(0表周日)
数字可由这些代替：“*”表任意  “，”表分隔的不同时间  “-”表连续的时间 
“*/n”表示每隔单位时间n；

2.4.3 守护进程(daemons)独立于终端并周期性地执行某些任务，与Windows的“服务”有点相似，可以使用ntsysv命令查看系统中有哪些守护进程。分为xinetd和独立启动的stand alone两类，stand alone会自行运行，相应快；而xinetd进程则是由一个统一的stand alone守护进程来负责唤起—它叫super daemon，那么xinetd的优点就在于不唤起的进程不会占用系统资源。stand alone守护进程的启动脚本放置在公认目录/etc/init.d，xinetd进程脚本放在/etc/xinetd.d目录下。
