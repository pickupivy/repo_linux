
进程是操作系统资源管理和分配的基本单位；

进程是一个动态的实体，是程序的一次执行过程。
掌握进程的概念就要将其与程序、线程两个概念区别开。
进程和程序的区别在于进进程是动态的，程序是静态的；
进程是运行行中的程序，程序是一些保存在硬盘上的可执行的代码。

线程是进程的执行流，是比进程更小的能独立运行的基本单位。
线程基本上不拥有系统资源，而进程拥有独立的内存单元，其内部的线程共享这些内存。
进程之间,彼此的地址空间是独立的,但线程会共享内存地址空间。

多个线程之间需要同步。多个线程生活在进程地址空间这同一个屋檐下,若存在多个线程操作共享资源,则需要同步,否则可能会出现结果错误、数据结构遭到破坏甚至是程序崩溃等后果。因此多线程编程中存在临界区的概念,临界区的代码只允许一个线程执行,线程提供了锁机制来保护临界区。当其他线程来到临界区却无法申请到锁时,就可能陷入阻塞,不再处于可执行状态,线程可能不得不让出 CPU 资源。如果设计不合理,临界区非常多,线程之间的竞争异常激烈,频繁地上下文切换也会导致性能急剧恶化。客观地说,多线程编程的难度要更大一些,需要程序员更加小心,更加谨慎。当你需要使用多线程的时候,一定要花费足够的时间小心地规划每个线程的分工,尽可能地减少线程之间的依赖。良好的设计,合理的分工是多线程编程至关重要的环节。
线程组内的第一个线程,在用户态被称为主线程( main thread ),在内核中被称为 Group Leader 。内核在创建第一个线程时,会将线程组 ID 的值设置成第一个线程的线程ID , group_leader 指针则指向自身,即主线程的进程描述符。

pid_t getpid(id)	获取进程ID
pid_t getppid(id)	获取父进程ID
pid_t getuid(id)	获取进程的实际用户ID
pid_t geteuid(id)	获取进程的有效用户ID
pid_t getgid(id)	获取进程的实际组ID
pid_t getegid(id)	获取进程的有效组ID

text段(正文段)(代码段)存放程序的可执行代码：二进制机器码，且为只读的，可以被多个进程共享。
data段(数据段)存放程序的全局变量、常量、静态变量；
bss 段 - 存放未初始化的数据
堆栈段的堆heap：存放动态分配的内存变量；
堆栈段的栈stack：用于函数调用，存放函数的返回地址、函数的参数、函数内部定义的局部变量。

fork:用于创建一个新的进程
exit:用于终止进程
exec:用于执行一个应用程序
wait:将父进程挂起，等待子进程终止
getpid:获取当前进程的ID
nice:改变进程的优先级

#include <unistd.h>
pid_t fork(void);
fork 之后的子进程完全拷贝了父进程的地址空间,包括栈、堆、代码段等。

预处理、编译、汇编、链接。

内核将程序读入内存，并分配内存空间；
内核为进程分配标识符PID和其他资源；
内核保存PID和状态信息，把进程放入运行队列等待执行。

创建进程有两种方式，一是由操作系统创建，二是由父进程创建。
由操作系统创建的进程，它们之间是平等的，一般不存在资源继承关系。
而对于由父进程创建的进程(通常称为子进程)，它们和父进程存在隶属关系。
子进程又可以创建进程:，这样形成一个进程家族。子进程可以继承其父进程几乎所有的资源。
在系统启动时，操作系统会创建一些进程，它们承担着管理和分配系统资源的任务，通常被称为系统进程。

系统调用fork是创建一个新进程的唯一方法；
创建了一个一子进程之后，父进程和子进程争夺CPU，抢到CPU者执行，另外一个挂起等待。
如果想要父进程等待子进程执行完毕以后再继续执行，可以在Fork操作之后调用wait或waitpid。
一个刚刚被fork的子进程会和它的父进程一样，继续执行当前的程序。几个进程同时执行一个应用程序通常用处不大。
更常见的使用方法是子进程在被fork后可以通过调用exec函数执行其他程序。

vfork和fork一样都是调用一次，返回两次。使用fork创建一个子进程时，子进程只是完全复制父进程的资源；
而使用vfork创建一个子进程时，操作系统并不将父进程的地址空间完全复制到子进程，
用vfork创建的子进程共享父进程的地址空间，子进程在该地址空间上的数据修改为父进程所见。
vfork一个进程时，vfork保证子进程先运行，当它调用exec或exit之后，父进程才可能被调度运行；
如果在调用exec或exit之前子进程需要依靠父进程的某个行为，就会导致死锁。vfork大大减小了系统开销。

exit是正常终止，abort是异常终止。exit()是先执行一些清除操作再将控制权返回给内核，
_exit()是执行后立即返回给内核，而return将控制权交给调用函数。
父子进程终止的先后顺序不同会产生不同的结果。在子进程退出前父进程先退出，则系统会让init进程接管子进程；
当子进程先于父进程终止，而父进程又没有调用wait函数等待子进程结束，
子进程进入僵死状态，并且会一直保持下去除非系统重启。
子进程处于僵死状态时，内核只保存该进程的一些必要信息以备父进程所需。
此时子进程始终占用着资源，同时也减少了系统可以创建的最大进程数。
如果子进程先于父进程终止，且父进程调用了wait或waitpid函数，则父进程会等待子进程结束。

使用fork或vfork创建子进程后，子进程通常会调用exec函数来执行另外一个程序。
系统调用exec用于执行一个可执行程序以代替当前进程的执行映像。
注意:exec调用并没有生成新进程。一个进程一旦调用exec函数，它本身就“死亡”了，
系统把代码段替换成新的程序的代码，度弃原有的数据段和堆栈段，并为新程序分配新的数据段与堆找段，
帷一保留的就是进程ID。也就是说，就系统而言，还是同一个进程，不过执行的已经是另外一个程序了。

例如processimage.c里的main(int argc, char * argv[], char ** environ)
execve("processimage", argv, environ)如此调用
#include <stdio.h> <sys/types.h> <unistd.h>

#include <sys/types.h> <sys/wait.h>
pid_t wait(int *statloc);
pid_t waitpid(pid_t pid, int *statloc, int options);
wait函数使父进程暂停执行，直到它的一个子进程结束为止。该函数的返回值是终止运行的子进程的PID。
参数statloc所指向的变量存放了进程的退出码，即从子进程的main函数返回的值或子进程中exit函数的参数。
如果statloc不是一个空指针，状态信息将被写入它指向的变量。

