
在使用gcc编译程序时，编译过程可以分为4个阶段：
(1)预处理：(Pre-Processing)：	gcc -E test.c -o test.i
(2)编译：(Compiling): 		gcc -S test.i -o test.s
(3)汇编：(Assemhiing): 		gcc -c test.s -o test.o
(4)链接：(Linking): 		gcc test.o -o test

(1)预处理：(Pre-Processing):在预处理阶段，输入的是C语言的源文件，通常为*.c或*.C，它们一般带有*.h之类的头文件。这个阶段主要处理源文件中的#ifdef、#includc和#define预处理命令。该阶段会生成一个中间文件*.i，但实际工作中一般不用专门生成这种文件。
(2)编译：(Compiling):在编译阶段，输入的是中间文件*.i，编译后生成汇编语言文件*.s
(3)汇编：(Assemhiing):在汇编阶段，将输入的汇编文件*.s转换成二进制机器代码*.o
(4)链接：(Linking):最后，在链接阶段将输入的二进制机器代码文件*.o(与其他的机器代码文件和库文件)汇集成一个可执行的二进制代码文件，这一步骤，可以使用下面的示例命令完成: gcc test.o -o test 最终生成了可执行文件。

对于上述过程可以简化为：
gcc -c test.c -o test.o
gcc test.o -o test
或者直接使用一条命令：
gcc test.c -o test

Makefile中有两种依赖，一种是前面介绍显式规则时提到的依赖。对于这种依赖类型，依赖文件列表中任何一个文件的时间如果比目标文件新都将导致规则中的命令被执行，从而生成新的目标文件。还有一种依赖，如下所示:
foo : foo.c | somelib
	gcc -o foo foo.c somelib
“|”前面的文件是普通依赖文件，如果foo.c过时，将导致foo重新生成。而如果“|”后面的文件过时，foo不会被重新生成，也就是第二行的命令不会被执行。

命令行属性
一条规则中可以有一个或多个命令行，每个命令行以Tab键开头。可以在Tab键后先写巨一个加号+、减号-或@，然后再写上命令。如果在Tab键后没有加上这3个符号中的一个，make使用缺省的命令行属性:执行该命令行的命令时打印出命令，命令执行遇到错误就退出make。
各符号的意义如下。
-:执行本命令行的命令时如果遇到错误，继续执行而不退出make
+:本行命令始终被执行，即使运行make命令时使用了-n、-a、-t选项(前提是本行命令所在规则的目标文件己经过时，需要执行命令以更新目标文件)。
@:执行本行命令时不在屏幕上打印命令的内容
例如，在某Makefile文件中有如下规则：
file.o : file.c head1.h head2.h
	-mv file.o /tmp
	gcc -c file.c
这个规则的含义是:如果发现file.o过时，先将过时的file.o文件备份到下，然后再生成新的目标文件。在第一次执行Makefile文件中的命令时，由于file.o不存在，mv命令就会出错，默认情祝下一旦出错make就会停止运行。但在mv命令前加上减号-后，遇到错误，make忽略它而继续执行。


在使用make编译程序时，可以先执行命令“make”以生成最终的可执行程序，但在这个过程中往往生成了很多诸如以.o结尾的中间文件。此时如果Makefile文件的最后有上面那条规则，我们就可以执行命令“make clean”来删除那些不必要的中间文件。
如果在当前工作日录下存在一个名为clean的文件，情况就不一样了，同样我们输入“make clean”，由于这个规则没有任何依赖文件，所以目标文件(即clean)被认为是最新而不去执行规则中的命令，因此命令“rm”将不会被执行。这并不是我们所希望的。为了解决这个问题，我们需要将目标“clean”声明为伪目标。将一个目标声明为伪目标的方法是将它作为特殊目标“.PHONY”的依赖。如下:
        .PHONY:clean
这样目标“clean”就被声明为一个伪目标。无论在当前目录下是否存在“clean”这个文件，输入“make clean”之后，“rm”命令都会被执行。而且，当一个日标被声明为伪目标后，make在执行此规则时不会试图去查找该目标的依赖文件。这样也提高了make的执行效率，同时也不用担心由于目标和文件名重名而不能实现我们的目的。在书写伪目标规则时，首先需要声明目标
是一个伪目标，之后才是伪目标的规则定义。目标“clean”的完整书写格式应该如下:
.PHONY: clean
clean:
	-rm -f *.o
.PHONY目标所在规则中的命令，无论目标文件是否存在都会无条件执行。

make首先会在当前目录下寻找名为“Makefile"或”makefile"的文件。

如果某一行过长，可以在行末输入一个反斜杠(\)，由反斜杠连起来的多行被当作一行处理，注意反斜杠与新的一行之间不要有空白。
#代表注释，如果要用到#这个字符，需要加转义字符\#
Makefile中符号“$”有特殊的含义(表示使用变量或调用函数)，在规则中需要使用符号“$”的地方，需要书写两个连续的$，即“$$"。

Makefile也可以命名为其它任意合法的文件名，执行命令为：
make -f othername(make --file=othername)

隐式规则：
module1.o: head1.h 
等价于
module1.o:module1.c head1
	gcc -c module1.c -o module1.o

使用变量：可以使用一个字符串代表一个文本串，在被make解释执行时，会做替换，类似于C中的宏
文件指示：类似于C中的include，就是在一个Makefile中包含另一个Makefile。

在Makefile中，所有的Tab键都会被当作命令行来处理。

all: prg1 prg2
.PHONY: all
prg1: prg1.c utils.h
	gcc -o prg1 prg1.c
prg2: prg2.c utils.h
	gcc -o prg2 prg2.c
会所有目标都被执行更新。

.IGNORE类似于-，当此目标没有依赖文件时，将忽略所有命令执行时的错误
.SILENT类似于@，当此目标没有依赖文件时，Makefile中的所有命令在执行时都不会打印

给make指定搜索依赖文件的路径
定义变量VPATE = /usr/src:../headers
这样就为所有规则指定了两个搜索目录，"/usr/src"和"../headers"
当然，也可以使用vpath(注意时小写)关键字，比如：
vpath %.c src1
vpath % src2
vpath %.h header:src
%号表示匹配字符


