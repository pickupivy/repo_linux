
多线程程序的优点（相对进程比较而言）：
1. 多个线程，它们彼此之间使用相同的地址空间，共享大部分数据，启动一个线程所花费的空间远远小于启动一个进程所花费的空间，而且，线程间彼此切换所需的时间也远远小于进程间切换所需要的时间，创建销毁速度快。
2.是线程间方便的通信机制。由于同一进程下的线程之间共享数据空间，所以一个线程的数据可以直接为其它线程所用，这不仅快捷，而且方便。

线程ID，不同于后面会讲到的pthread_t类型的线程ID，和进程ID一样，线程ID是pid_t类型的变量，而且是用来唯一标识线程的一
个整型变量。
多线程的进程，又被称为线程组，线程组内的每一个线程在内核之中都存在一个进程描述符（task_struct）与之对应。进程描述符结构体中的pid，表面上看对应的是进程ID，其实不然，它对应的是线程ID；进程描述符中的tgid，含义是Thread Group ID，该值对应的是用户层面的进程ID.

ps命令中的-L选项，会显示出线程的如下信息。
·LWP：线程ID，即gettid（）系统调用的返回值。
·NLWP：线程组内线程的个数。

用户态	系统调用	内核进程描述符中对应的结构
线程ID	pid_t gettid(void)	pid_t pid
进程ID	pid_t getpid(void)	pid_t pid
函数gettid()可以得到tid，但glibc并没有实现该函数，只能通过Linux的系统调用syscall来获取。
pid_t tid;
tid = syscall(SYS_gettid);

用户调用pthread_create函数时，glibc首先要为线程分配线程栈，而线程栈的位置就落在mmap区域。glibc会调用mmap函数为线程分配栈空间。pthread_create函数分配的pthread_t类型的线程ID，不过是分配出来的空间里的一个地址，更确切地说是一个结构体的指针.

线程ID是进程地址空间内的一个地址，要在同一个线程组内进行线程之间的比较才有意义。不同线程组内的两个线程，哪怕两者的pthread_t值是一样的，也不是同一个线程，这是显而易见的。很有意思的一点是，pthread_t类型的线程ID很有可能会被复用。在满足下列条件时，线程ID就有可能会被复用：
1）线程退出。
2）线程组的其他线程对该线程执行了pthread_join，或者线程退出前将分离状态设置为已分离。
3）再次调用pthread_create创建线程。

互斥：
1）代码必须要有互斥的行为：当一个线程正在临界区中执行时，不允许其他线程进入该临界区
中。
2）如果多个线程同时要求执行临界区的代码，并且当前临界区并没有线程在执行，那么只能允许
一个线程进入该临界区。
3）如果线程不在临界区中执行，那么该线程不能阻止其他线程进入临界区。

